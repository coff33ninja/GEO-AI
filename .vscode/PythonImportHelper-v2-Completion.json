[
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "SumTree",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)\n        self.data = np.zeros(capacity, dtype=object)\n        self.write = 0\n        self.n_entries = 0\n    def add(self, priority, data):\n        idx = self.write + self.capacity - 1\n        self.data[self.write] = data",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "DQN",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class DQN(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super(DQN, self).__init__()\n        self.fc1 = nn.Linear(input_dim, 128)\n        self.fc2 = nn.Linear(128, 64)\n        self.fc3 = nn.Linear(64, output_dim)\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "ForwardModel",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class ForwardModel(nn.Module):\n    def __init__(self, state_dim, action_dim):\n        super().__init__()\n        self.fc1 = nn.Linear(state_dim + 1, 128)  # Action is a scalar\n        self.fc2 = nn.Linear(128, state_dim)\n    def forward(self, state, action):\n        try:\n            if state.dim() != 2 or action.dim() != 2:\n                raise ValueError(\n                    f\"Expected 2D tensors, got state shape {state.shape}, action shape {action.shape}\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class WorldModel(nn.Module):\n    def __init__(self, state_dim, action_dim):\n        super().__init__()\n        self.fc1 = nn.Linear(state_dim + 1, 128)\n        self.fc2 = nn.Linear(128, state_dim)\n    def forward(self, state, action):\n        try:\n            if state.dim() != 2 or action.dim() != 2:\n                raise ValueError(\n                    f\"Expected 2D tensors, got state shape {state.shape}, action shape {action.shape}\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "NextShapePredictor",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class NextShapePredictor(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super(NextShapePredictor, self).__init__()\n        self.fc1 = nn.Linear(input_dim, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, output_dim)\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "to_int_point",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2\n        or not all(isinstance(coord, (int, float)) for coord in point)\n    ):\n        print(f\"Invalid point detected: {point}\")\n        return (0, 0)\n    return (int(point[0]), int(point[1]))\n# Geometric Worlds and Tasks",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "stereographic_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def stereographic_projection(point, R=100):\n    x, y, z = point\n    if z == 2 * R:\n        return None\n    factor = 2 * R / (2 * R - z)\n    proj_x = factor * x + WIDTH / 2\n    proj_y = factor * y + HEIGHT / 2\n    return (proj_x, proj_y)\ndef poincare_disk_projection(point, R=100):\n    x, y = point",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "poincare_disk_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def poincare_disk_projection(point, R=100):\n    x, y = point\n    dist = np.sqrt(x**2 + y**2)\n    if dist >= R:\n        return None\n    factor = R * np.tanh(dist / R)\n    angle = np.arctan2(y, x)\n    proj_x = factor * np.cos(angle) + WIDTH / 2\n    proj_y = factor * np.sin(angle) + HEIGHT / 2\n    return (proj_x, proj_y)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "elliptical_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def elliptical_projection(point, a=150, b=100):\n    x, y = point\n    proj_x = (x / a) * (WIDTH / 2) + WIDTH / 2\n    proj_y = (y / b) * (HEIGHT / 2) + HEIGHT / 2\n    return (proj_x, proj_y)\ndef projective_projection(point, fov=90, near=1):\n    x, y = point\n    z = 100\n    if z <= 0:\n        return None",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "projective_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def projective_projection(point, fov=90, near=1):\n    x, y = point\n    z = 100\n    if z <= 0:\n        return None\n    proj_x = (x * near / z) * (WIDTH / 2) + WIDTH / 2\n    proj_y = (y * near / z) * (HEIGHT / 2) + HEIGHT / 2\n    return (proj_x, proj_y)\ndef fractal_projection(point, iterations=3):\n    x, y = point",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "fractal_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def fractal_projection(point, iterations=3):\n    x, y = point\n    x, y = x / WIDTH, y / HEIGHT\n    for _ in range(iterations):\n        r = np.random.randint(3)\n        if r == 0:\n            x, y = x / 2, y / 2\n        elif r == 1:\n            x, y = (x + 1) / 2, y / 2\n        else:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "project_point",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def project_point(point, world):\n    x, y = point\n    if world == WORLD_EUCLIDEAN:\n        return (x + WIDTH / 2, y + HEIGHT / 2)\n    elif world == WORLD_SPHERICAL:\n        z = np.sqrt(max(0, 100**2 - x**2 - y**2))\n        return stereographic_projection((x, y, z))\n    elif world == WORLD_HYPERBOLIC:\n        return poincare_disk_projection((x - WIDTH / 2, y - HEIGHT / 2))\n    elif world == WORLD_ELLIPTICAL:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "hyperbolic_geodesic",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def hyperbolic_geodesic(start, end, R=100):\n    start = (start[0] - WIDTH / 2, start[1] - HEIGHT / 2)\n    end = (end[0] - WIDTH / 2, end[1] - HEIGHT / 2)\n    start_r = np.sqrt(start[0] ** 2 + start[1] ** 2)\n    end_r = np.sqrt(end[0] ** 2 + end[1] ** 2)\n    if start_r >= R or end_r >= R:\n        return []\n    start_angle = np.arctan2(start[1], start[0])\n    end_angle = np.arctan2(end[1], end[0])\n    points = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_wireframe",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_wireframe(world):\n    global animation_time\n    animation_time += 0.05\n    pulse = 0.5 + 0.5 * np.sin(animation_time)\n    def gradient_color(t):\n        r = int(0 * (1 - t) + 0 * t)\n        g = int(0 * (1 - t) + 255 * t)\n        b = int(255 * (1 - t) + 255 * t)\n        return (r, g, b)\n    if world == WORLD_EUCLIDEAN:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_line_segment",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_line_segment(start, end, curvature, world):\n    try:\n        if not (isinstance(start, (tuple, list)) and isinstance(end, (tuple, list))):\n            raise ValueError(f\"Invalid start or end point: start={start}, end={end}\")\n        if len(start) != 2 or len(end) != 2:\n            raise ValueError(\n                f\"Start and end must be 2D points: start={start}, end={end}\"\n            )\n        if world == WORLD_HYPERBOLIC:\n            return hyperbolic_geodesic(start, end)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_triangle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_triangle(points, angle_adjust, world):\n    try:\n        if len(points) < 3:\n            return points\n        if not all(isinstance(p, (tuple, list)) and len(p) == 2 for p in points):\n            raise ValueError(f\"Invalid points for triangle: {points}\")\n        new_points = points.copy()\n        p1, p2, p3 = points\n        dx = p3[0] - p2[0]\n        dy = p3[1] - p2[1]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_circle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_circle(center, radius, radius_adjust, world):\n    radius = max(10, radius + radius_adjust)\n    points = []\n    for theta in np.linspace(0, 2 * np.pi, 20):\n        x = center[0] + radius * np.cos(theta)\n        y = center[1] + radius * np.sin(theta)\n        proj = project_point((x - WIDTH / 2, y - HEIGHT / 2), world)\n        if proj:\n            points.append(proj)\n    return points, radius",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_pentagon",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_pentagon(points, angle_adjust, world):\n    if len(points) < 5:\n        return points\n    new_points = points.copy()\n    for i in range(2, 5):\n        p1 = new_points[i - 1]\n        p2 = new_points[i]\n        dx = p2[0] - p1[0]\n        dy = p2[1] - p1[1]\n        angle = np.arctan2(dy, dx) + angle_adjust * np.pi / 180",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_tessellation",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_tessellation(points, world):\n    if len(points) < 3:\n        return points\n    base_triangle = points[:3]\n    tessellation = [base_triangle]\n    center_x = sum(p[0] for p in base_triangle) / 3\n    center_y = sum(p[1] for p in base_triangle) / 3\n    for i in range(3):\n        p1 = base_triangle[i]\n        p2 = base_triangle[(i + 1) % 3]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "macro_action_draw_triangle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def macro_action_draw_triangle(current_shape, world):\n    actions = []\n    if len(current_shape) < 3:\n        for _ in range(3 - len(current_shape)):\n            actions.append(3)\n    return actions\ndef macro_action_draw_circle(center, radius, world):\n    actions = []\n    for _ in range(3):\n        actions.append(4)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "macro_action_draw_circle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def macro_action_draw_circle(center, radius, world):\n    actions = []\n    for _ in range(3):\n        actions.append(4)\n    return actions\n# Helper Functions\ndef calculate_triangle_angle(points):\n    if len(points) < 3:\n        return 0\n    p1, p2, p3 = points",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "calculate_triangle_angle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def calculate_triangle_angle(points):\n    if len(points) < 3:\n        return 0\n    p1, p2, p3 = points\n    v1 = np.array([p2[0] - p1[0], p2[1] - p1[1]])\n    v2 = np.array([p3[0] - p2[0], p3[1] - p2[1]])\n    if np.linalg.norm(v1) == 0 or np.linalg.norm(v2) == 0:\n        return 0\n    angle = (\n        np.arccos(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "calculate_dist_to_close",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def calculate_dist_to_close(points):\n    if len(points) < 2:\n        return 0\n    p1, p_last = points[0], points[-1]\n    return np.sqrt((p1[0] - p_last[0]) ** 2 + (p1[1] - p_last[1]) ** 2)\n# Reward Function\ndef calculate_reward(shape, target, task, world):\n    try:\n        reward = 0\n        if task == TASK_LINE:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "calculate_reward",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def calculate_reward(shape, target, task, world):\n    try:\n        reward = 0\n        if task == TASK_LINE:\n            if not shape:\n                return -10\n            current_pos = shape[-1] if shape else (0, 0)\n            if not (isinstance(current_pos, (tuple, list)) and len(current_pos) == 2):\n                raise ValueError(f\"Invalid current_pos: {current_pos}\")\n            if not (isinstance(target, (tuple, list)) and len(target) == 2):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimize_model",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def optimize_model():\n    if memory.n_entries < batch_size:\n        return\n    total_priority = memory.tree[0]\n    batch = []\n    idxs = []\n    priorities = []\n    segment = total_priority / batch_size\n    for i in range(batch_size):\n        a = segment * i",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "store_transition",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def store_transition(transition):\n    n_step_buffer.append(transition)\n    if len(n_step_buffer) < n_step:\n        return\n    cumulative_reward = sum([(gamma**i) * t[2] for i, t in enumerate(n_step_buffer)])\n    state, action = n_step_buffer[0][0], n_step_buffer[0][1]\n    next_state, done = n_step_buffer[-1][3], n_step_buffer[-1][4]\n    memory.add(1.0, (state, action, cumulative_reward, next_state, done))\n    n_step_buffer.pop(0)\ndef plan_actions(state_tensor, model, current_shape, target, task, world, steps=3):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "plan_actions",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def plan_actions(state_tensor, model, current_shape, target, task, world, steps=3):\n    best_sequence = []\n    best_reward = -float(\"inf\")\n    state = state_tensor.squeeze(0).cpu().numpy()\n    for _ in range(10):\n        sequence = [np.random.randint(action_dim) for _ in range(steps)]\n        sim_state = state.copy()\n        sim_shape = current_shape.copy()\n        total_reward = 0\n        for action in sequence:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "console_input",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def console_input():\n    global command, running_state, tick_rate, train_iters\n    while True:\n        cmd = (\n            input(\n                \"Enter command (start, pause, resume, quit, faster, slower, iters_up, iters_down): \"\n            )\n            .strip()\n            .lower()\n        )",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "adjust_learning_rate",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def adjust_learning_rate(fps):\n    global optimizer\n    avg_reward = sum(episode_rewards) / len(episode_rewards) if episode_rewards else 0\n    current_lr = base_lr\n    if avg_reward > 10:\n        current_lr = min(base_lr * 2, 0.01)\n    elif avg_reward < -5:\n        current_lr = max(base_lr * 0.5, 0.0001)\n    if fps < 20:\n        current_lr *= 0.8",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "predict_next_shape",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def predict_next_shape():\n    global current_task, reward_history\n    avg_reward = sum(episode_rewards) / len(episode_rewards) if episode_rewards else 0\n    state = np.array(\n        [tasks.index(current_task), worlds.index(current_world), avg_reward]\n        + list(reward_history)\n        + [0] * (10 - len(reward_history))\n    )\n    state_tensor = torch.FloatTensor(state).unsqueeze(0).to(device)\n    with torch.no_grad():",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "reset_episode",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def reset_episode():\n    global start_point, triangle_points, circle_center, pentagon_points, tessellation_points, current_shape, game_state, ai_step\n    if current_task == TASK_LINE:\n        start_point = (random.randint(50, WIDTH - 50), random.randint(50, HEIGHT - 50))\n        current_shape = [start_point]\n    elif current_task == TASK_TRIANGLE:\n        triangle_points = [\n            (random.randint(50, WIDTH - 50), random.randint(50, HEIGHT - 50))\n            for _ in range(3)\n        ]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "update_reward_plot",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def update_reward_plot():\n    global plot_surface, episode_rewards\n    plt.figure(figsize=(4, 2))\n    plt.plot(list(episode_rewards), label=\"Reward\", color=\"cyan\")\n    plt.xlabel(\"Episode\")\n    plt.ylabel(\"Avg Reward\")\n    plt.title(\"Reward Trend\")\n    plt.legend()\n    buf = BytesIO()\n    plt.savefig(buf, format=\"png\", bbox_inches=\"tight\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WIDTH",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WIDTH = 800\nHEIGHT = 600\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"GeoMaster AI Challenge - Next Shape Predictor\")\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "HEIGHT",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "HEIGHT = 600\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"GeoMaster AI Challenge - Next Shape Predictor\")\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "screen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"GeoMaster AI Challenge - Next Shape Predictor\")\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "BLACK",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "BLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WHITE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):\n    if (",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "RED",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "RED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "BLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "CYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2\n        or not all(isinstance(coord, (int, float)) for coord in point)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "GREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2\n        or not all(isinstance(coord, (int, float)) for coord in point)\n    ):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "font = pygame.font.SysFont(\"monospace\", 20)\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2\n        or not all(isinstance(coord, (int, float)) for coord in point)\n    ):\n        print(f\"Invalid point detected: {point}\")\n        return (0, 0)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_EUCLIDEAN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_EUCLIDEAN = \"Euclidean\"\nWORLD_SPHERICAL = \"Spherical\"\nWORLD_HYPERBOLIC = \"Hyperbolic\"\nWORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_SPHERICAL",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_SPHERICAL = \"Spherical\"\nWORLD_HYPERBOLIC = \"Hyperbolic\"\nWORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_HYPERBOLIC",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_HYPERBOLIC = \"Hyperbolic\"\nWORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_ELLIPTICAL",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_PROJECTIVE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,\n]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_FRACTAL",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,\n]\ncurrent_world = WORLD_EUCLIDEAN",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "worlds",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "worlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,\n]\ncurrent_world = WORLD_EUCLIDEAN\nTASK_LINE = \"Draw Line\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_world",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_world = WORLD_EUCLIDEAN\nTASK_LINE = \"Draw Line\"\nTASK_TRIANGLE = \"Draw Triangle\"\nTASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_LINE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_LINE = \"Draw Line\"\nTASK_TRIANGLE = \"Draw Triangle\"\nTASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_TRIANGLE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_TRIANGLE = \"Draw Triangle\"\nTASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_CIRCLE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_PENTAGON",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)\n        self.data = np.zeros(capacity, dtype=object)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_TESSELLATION",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)\n        self.data = np.zeros(capacity, dtype=object)\n        self.write = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "tasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)\n        self.data = np.zeros(capacity, dtype=object)\n        self.write = 0\n        self.n_entries = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_task",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_task = TASK_LINE\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)\n        self.data = np.zeros(capacity, dtype=object)\n        self.write = 0\n        self.n_entries = 0\n    def add(self, priority, data):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "state_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "state_dim = 10\naction_dim = 6\npredictor_input_dim = 13  # task_id, world_id, avg_reward, last 10 rewards\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "action_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "action_dim = 6\npredictor_input_dim = 13  # task_id, world_id, avg_reward, last 10 rewards\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "predictor_input_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "predictor_input_dim = 13  # task_id, world_id, avg_reward, last 10 rewards\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "predictor_output_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "predictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "gamma",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "gamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_start",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_end",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_decay",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "batch_size",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "batch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "memory_size",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "memory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "target_update",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "target_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "n_step",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "n_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "alpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "beta",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "beta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "base_lr",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "base_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "policy_net",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "policy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "target_net",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "target_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "forward_model",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "forward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer_fm",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Game State",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "world_model",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "world_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Game State\nstart_point = None",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer_wm",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Game State\nstart_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "shape_predictor",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "shape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(\n    device\n)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Game State\nstart_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer_sp",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Game State\nstart_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "memory",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "memory = SumTree(memory_size)\nn_step_buffer = []\n# Game State\nstart_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "n_step_buffer",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "n_step_buffer = []\n# Game State\nstart_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "start_point",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "start_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "end_point",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "end_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "triangle_points",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "triangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "circle_center",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "circle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "circle_radius",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "circle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "pentagon_points",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "pentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tessellation_points",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "tessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_shape",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "ai_step",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "ai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "max_steps",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "max_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "game_state",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "game_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "running_state",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "running_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "rewards",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "rewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "episode_rewards",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "episode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "reward_history",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "reward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_reward",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "global_step",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "global_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "episode_count",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "episode_count = 0\ntick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tick_rate",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "tick_rate = 30\ntrain_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "train_iters",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "train_iters = 1\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [\n                \"Episode\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "log_file",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "log_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [\n                \"Episode\",\n                \"Step\",\n                \"State\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "file_exists",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "file_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [\n                \"Episode\",\n                \"Step\",\n                \"State\",\n                \"Action\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "animation_time",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "animation_time = 0\ndef draw_wireframe(world):\n    global animation_time\n    animation_time += 0.05\n    pulse = 0.5 + 0.5 * np.sin(animation_time)\n    def gradient_color(t):\n        r = int(0 * (1 - t) + 0 * t)\n        g = int(0 * (1 - t) + 255 * t)\n        b = int(255 * (1 - t) + 255 * t)\n        return (r, g, b)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "command = \"\"\ndef console_input():\n    global command, running_state, tick_rate, train_iters\n    while True:\n        cmd = (\n            input(\n                \"Enter command (start, pause, resume, quit, faster, slower, iters_up, iters_down): \"\n            )\n            .strip()\n            .lower()",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "lock = threading.Lock()\nthreading.Thread(target=console_input, daemon=True).start()\n# Adaptive Learning Rate\ndef adjust_learning_rate(fps):\n    global optimizer\n    avg_reward = sum(episode_rewards) / len(episode_rewards) if episode_rewards else 0\n    current_lr = base_lr\n    if avg_reward > 10:\n        current_lr = min(base_lr * 2, 0.01)\n    elif avg_reward < -5:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "plot_surface",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "plot_surface = None\ndef update_reward_plot():\n    global plot_surface, episode_rewards\n    plt.figure(figsize=(4, 2))\n    plt.plot(list(episode_rewards), label=\"Reward\", color=\"cyan\")\n    plt.xlabel(\"Episode\")\n    plt.ylabel(\"Avg Reward\")\n    plt.title(\"Reward Trend\")\n    plt.legend()\n    buf = BytesIO()",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "clock",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "clock = pygame.time.Clock()\nrunning = True\nlast_plot_update = 0\nstep_counter = 0\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n    with lock:\n        if command == \"quit\":",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "running",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "running = True\nlast_plot_update = 0\nstep_counter = 0\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n    with lock:\n        if command == \"quit\":\n            running = False",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "last_plot_update",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "last_plot_update = 0\nstep_counter = 0\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n    with lock:\n        if command == \"quit\":\n            running = False\n    if running_state == \"running\" and game_state == \"waiting\":",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "step_counter",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "step_counter = 0\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n    with lock:\n        if command == \"quit\":\n            running = False\n    if running_state == \"running\" and game_state == \"waiting\":\n        reset_episode()",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    }
]