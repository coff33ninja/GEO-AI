[
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "SumTree",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class SumTree:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.tree = np.zeros(2 * capacity - 1)\n        self.data = np.zeros(capacity, dtype=object)\n        self.write = 0\n        self.n_entries = 0\n    def add(self, priority, data):\n        idx = self.write + self.capacity - 1\n        self.data[self.write] = data",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "DQN",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class DQN(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super(DQN, self).__init__()\n        self.fc1 = nn.Linear(input_dim, 128)\n        self.fc2 = nn.Linear(128, 64)\n        self.fc3 = nn.Linear(64, output_dim)\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "ForwardModel",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class ForwardModel(nn.Module):\n    def __init__(self, state_dim, action_dim):\n        super().__init__()\n        self.state_dim = state_dim  # Store state_dim as an instance variable\n        self.fc1 = nn.Linear(state_dim + 1, 128)\n        self.fc2 = nn.Linear(128, state_dim)\n    def forward(self, state, action):\n        try:\n            log_message(f\"ForwardModel: state_dim={self.state_dim}, state.shape={state.shape}, action.shape={action.shape}\")\n            if state.dim() != 2 or action.dim() != 2:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class WorldModel(nn.Module):\n    def __init__(self, state_dim, action_dim):\n        super().__init__()\n        self.fc1 = nn.Linear(state_dim + 1, 128)\n        self.fc2 = nn.Linear(128, state_dim)\n    def forward(self, state, action):\n        try:\n            if state.dim() != 2 or action.dim() != 2:\n                raise ValueError(\n                    f\"Expected 2D tensors, got state shape {state.shape}, action shape {state.shape}\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "NextShapePredictor",
        "kind": 6,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "class NextShapePredictor(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super(NextShapePredictor, self).__init__()\n        self.fc1 = nn.Linear(input_dim, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, output_dim)\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "log_message",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def log_message(message):\n    if debug_mode:\n        log_queue.put(message)\ndef process_logs():\n    while not log_queue.empty():\n        print(log_queue.get())\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "process_logs",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def process_logs():\n    while not log_queue.empty():\n        print(log_queue.get())\n# Helper function\ndef to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2\n        or not all(isinstance(coord, (int, float)) for coord in point)\n    ):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "to_int_point",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def to_int_point(point):\n    if (\n        not isinstance(point, (tuple, list))\n        or len(point) != 2\n        or not all(isinstance(coord, (int, float)) for coord in point)\n    ):\n        log_message(f\"Invalid point detected: {repr(point)}\")\n        return (0, 0)\n    return (int(point[0]), int(point[1]))\n# Geometric Worlds and Tasks",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "update_curriculum",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def update_curriculum():\n    \"\"\"Update the curriculum stage based on performance.\"\"\"\n    global curriculum_stage, curriculum_progress\n    if curriculum_progress >= curriculum_threshold and curriculum_stage < len(curriculum_tasks) - 1:\n        curriculum_stage += 1\n        curriculum_progress = 0\n        log_message(f\"Curriculum advanced to stage {curriculum_stage}. Tasks: {curriculum_tasks[curriculum_stage]}, Worlds: {curriculum_worlds[curriculum_stage]}\")\n# --- SumTree for Prioritized Experience Replay ---\nclass SumTree:\n    def __init__(self, capacity):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "select_action",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:\n        # Exploration: Add noise to a random action\n        action = random.randint(0, action_dim - 1)\n        noise = np.random.normal(0, epsilon_noise_scale, size=action_dim)\n        noisy_action = np.clip(action + noise[action], 0, action_dim - 1)\n        return int(noisy_action)\n    else:\n        # Exploitation: Choose the best action",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "stereographic_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def stereographic_projection(point, R=100):\n    x, y, z = point\n    if z == 2 * R:\n        return (0, 0)\n    factor = 2 * R / (2 * R - z)\n    proj_x = factor * x + WIDTH / 2\n    proj_y = factor * y + HEIGHT / 2\n    return (proj_x, proj_y)\ndef poincare_disk_projection(point, R=100):\n    x, y = point",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "poincare_disk_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def poincare_disk_projection(point, R=100):\n    x, y = point\n    dist = np.sqrt(x**2 + y**2)\n    if dist >= R:\n        return (WIDTH / 2, HEIGHT / 2)\n    factor = R * np.tanh(dist / R)\n    angle = np.arctan2(y, x)\n    proj_x = factor * np.cos(angle) + WIDTH / 2\n    proj_y = factor * np.sin(angle) + WIDTH / 2\n    return (proj_x, proj_y)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "elliptical_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def elliptical_projection(point, a=150, b=100):\n    x, y = point\n    proj_x = (x / a) * (WIDTH / 2) + WIDTH / 2\n    proj_y = (y / b) * (HEIGHT / 2) + HEIGHT / 2\n    return (proj_x, proj_y)\ndef projective_projection(point, fov=90, near=1):\n    x, y = point\n    z = 100\n    if z <= 0:\n        return (WIDTH / 2, HEIGHT / 2)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "projective_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def projective_projection(point, fov=90, near=1):\n    x, y = point\n    z = 100\n    if z <= 0:\n        return (WIDTH / 2, HEIGHT / 2)\n    proj_x = (x * near / z) * (WIDTH / 2) + WIDTH / 2\n    proj_y = (y * near / z) * (HEIGHT / 2) + HEIGHT / 2\n    return (proj_x, proj_y)\ndef fractal_projection(point, iterations=3):\n    x, y = point",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "fractal_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def fractal_projection(point, iterations=3):\n    x, y = point\n    x, y = x / WIDTH, y / HEIGHT\n    for _ in range(iterations):\n        r = np.random.randint(3)\n        if r == 0:\n            x, y = x / 2, y / 2\n        elif r == 1:\n            x, y = (x + 1) / 2, y / 2\n        else:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "project_point",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def project_point(point, world):\n    x, y = point\n    if world == WORLD_EUCLIDEAN:\n        proj = (x + WIDTH / 2, y + HEIGHT / 2)\n    elif world == WORLD_SPHERICAL:\n        z = np.sqrt(max(0, 100**2 - x**2 - y**2))\n        proj = stereographic_projection((x, y, z))\n    elif world == WORLD_HYPERBOLIC:\n        proj = poincare_disk_projection((x - WIDTH / 2, y - HEIGHT / 2))\n    elif world == WORLD_ELLIPTICAL:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "hyperbolic_geodesic",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def hyperbolic_geodesic(start, end, R=100):\n    start = (start[0] - WIDTH / 2, start[1] - HEIGHT / 2)\n    end = (end[0] - WIDTH / 2, end[1] - HEIGHT / 2)\n    start_r = np.sqrt(start[0] ** 2 + start[1] ** 2)\n    end_r = np.sqrt(end[0] ** 2 + end[1] ** 2)\n    if start_r >= R or end_r >= R:\n        return []\n    start_angle = np.arctan2(start[1], start[0])\n    end_angle = np.arctan2(end[1], end[0])\n    points = []",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "perspective_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def perspective_projection(point, fov=90, aspect_ratio=WIDTH / HEIGHT, near=1, far=1000):\n    x, y, z = point\n    if z <= near:\n        return None\n    scale = 1 / np.tan(np.radians(fov) / 2)\n    proj_x = (scale * x / z) * WIDTH / 2 + WIDTH / 2\n    proj_y = (scale * y / z) * HEIGHT / 2 + HEIGHT / 2\n    return (proj_x, proj_y)\ndef orthographic_projection(point):\n    x, y, z = point",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "orthographic_projection",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def orthographic_projection(point):\n    x, y, z = point\n    proj_x = x + WIDTH / 2\n    proj_y = y + HEIGHT / 2\n    return (proj_x, proj_y)\n# Extend project_point to handle 3D\ndef project_point_3d(point, world, projection=\"perspective\"):\n    if len(point) == 3:\n        if projection == \"perspective\":\n            return perspective_projection(point)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "project_point_3d",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def project_point_3d(point, world, projection=\"perspective\"):\n    if len(point) == 3:\n        if projection == \"perspective\":\n            return perspective_projection(point)\n        elif projection == \"orthographic\":\n            return orthographic_projection(point)\n    return project_point(point, world)\n# Toggle between 2D and 3D modes\nis_3d_mode = False\nprojection_mode = \"perspective\"  # Options: \"perspective\", \"orthographic\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "update_network_dimensions",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def update_network_dimensions():\n    global policy_net, target_net, forward_model, world_model, state_dim\n    state_dim = state_dim_3d if is_3d_mode else state_dim_2d\n    log_message(f\"Updating network dimensions: state_dim={state_dim}, is_3d_mode={is_3d_mode}\")\n    policy_net = DQN(state_dim, action_dim).to(device)\n    target_net = DQN(state_dim, action_dim).to(device)\n    target_net.load_state_dict(policy_net.state_dict())\n    forward_model = ForwardModel(state_dim, action_dim).to(device)  # Re-initialize with updated state_dim\n    world_model = WorldModel(state_dim, action_dim).to(device)\n    global optimizer, optimizer_fm, optimizer_wm",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "toggle_3d_mode",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def toggle_3d_mode():\n    global is_3d_mode\n    is_3d_mode = not is_3d_mode\n    update_network_dimensions()\n    log_message(f\"3D mode {'enabled' if is_3d_mode else 'disabled'}\")\n# Extend tasks to 3D\ndef draw_line_segment_3d(start, end, curvature, world):\n    try:\n        if not (isinstance(start, (tuple, list)) and isinstance(end, (tuple, list))):\n            raise ValueError(f\"Invalid start or end point: start={repr(start)}, end={repr(end)}\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_line_segment_3d",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_line_segment_3d(start, end, curvature, world):\n    try:\n        if not (isinstance(start, (tuple, list)) and isinstance(end, (tuple, list))):\n            raise ValueError(f\"Invalid start or end point: start={repr(start)}, end={repr(end)}\")\n        if len(start) != 3 or len(end) != 3:\n            raise ValueError(f\"Start and end must be 3D points: start={repr(start)}, end={repr(end)}\")\n        points = []\n        num_points = 10\n        for i in range(num_points + 1):\n            t = i / num_points",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_triangle_3d",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_triangle_3d(points, angle_adjust, world):\n    try:\n        if len(points) != 3:\n            return points if len(points) < 3 else points[:3]\n        if not all(isinstance(p, (tuple, list)) and len(p) == 3 for p in points):\n            raise ValueError(f\"Invalid points for triangle: {repr(points)}\")\n        new_points = points.copy()\n        p1, p2, p3 = points\n        dx = p3[0] - p2[0]\n        dy = p3[1] - p2[1]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_circle_3d",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_circle_3d(center, radius, radius_adjust, world):\n    try:\n        radius = max(10, radius + radius_adjust)\n        points = []\n        for theta in np.linspace(0, 2 * np.pi, 20):\n            for phi in np.linspace(0, np.pi, 10):  # Add depth for 3D\n                x = center[0] + radius * np.sin(phi) * np.cos(theta)\n                y = center[1] + radius * np.sin(phi) * np.sin(theta)\n                z = center[2] + radius * np.cos(phi)\n                proj = project_point_3d((x, y, z), world)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_wireframe",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_wireframe(world):\n    global animation_time\n    animation_time += 0.05\n    pulse = 0.5 + 0.5 * np.sin(animation_time)\n    def gradient_color(t):\n        r = int(0 * (1 - t) + 0 * t)\n        g = int(0 * (1 - t) + 255 * t)\n        b = int(255 * (1 - t) + 255 * t)\n        return (r, g, b)\n    if world == WORLD_EUCLIDEAN:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_line_segment",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_line_segment(start, end, curvature, world):\n    try:\n        if not (isinstance(start, (tuple, list)) and isinstance(end, (tuple, list))):\n            raise ValueError(f\"Invalid start or end point: start={repr(start)}, end={repr(end)}\")\n        if len(start) != 2 or len(end) != 2:\n            raise ValueError(\n                f\"Start and end must be 2D points: start={repr(start)}, end={repr(end)}\"\n            )\n        if world == WORLD_HYPERBOLIC:\n            return hyperbolic_geodesic(start, end)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_triangle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_triangle(points, angle_adjust, world):\n    try:\n        if len(points) != 3:\n            return points if len(points) < 3 else points[:3]\n        if not all(isinstance(p, (tuple, list)) and len(p) == 2 for p in points):\n            raise ValueError(f\"Invalid points for triangle: {repr(points)}\")\n        new_points = points.copy()\n        p1, p2, p3 = points\n        dx = p3[0] - p2[0]\n        dy = p3[1] - p2[1]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_circle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_circle(center, radius, radius_adjust, world):\n    radius = max(10, radius + radius_adjust)\n    points = []\n    for theta in np.linspace(0, 2 * np.pi, 20):\n        x = center[0] + radius * np.cos(theta)\n        y = center[1] + radius * np.sin(theta)\n        proj = project_point((x - WIDTH / 2, y - HEIGHT / 2), world)\n        if proj:\n            points.append(proj)\n    return points, radius",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_pentagon",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_pentagon(points, angle_adjust, world):\n    if len(points) != 5:\n        return points if len(points) < 5 else points[:5]\n    new_points = points.copy()\n    for i in range(2, 5):\n        p1 = new_points[i - 1]\n        p2 = new_points[i]\n        dx = p2[0] - p1[0]\n        dy = p2[1] - p1[1]\n        angle = np.arctan2(dy, dx) + angle_adjust * np.pi / 180",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "draw_tessellation",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def draw_tessellation(points, world):\n    if len(points) < 3:\n        return [points]\n    base_triangle = points[:3]\n    tessellation = [base_triangle]\n    center_x = sum(p[0] for p in base_triangle) / 3\n    center_y = sum(p[1] for p in base_triangle) / 3\n    for i in range(3):\n        p1 = base_triangle[i]\n        p2 = base_triangle[(i + 1) % 3]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "macro_action_draw_triangle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def macro_action_draw_triangle(current_shape, world):\n    actions = []\n    if len(current_shape) < 3:\n        for _ in range(3 - len(current_shape)):\n            actions.append(3)\n    return actions\ndef macro_action_draw_circle(center, radius, world):\n    actions = []\n    for _ in range(3):\n        actions.append(4)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "macro_action_draw_circle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def macro_action_draw_circle(center, radius, world):\n    actions = []\n    for _ in range(3):\n        actions.append(4)\n    return actions\n# Helper Functions\ndef calculate_triangle_angle(points):\n    try:\n        if len(points) < 3:\n            return 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "calculate_triangle_angle",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def calculate_triangle_angle(points):\n    try:\n        if len(points) < 3:\n            return 0\n        # Flatten if nested (e.g., from tessellation)\n        flat_points = []\n        for p in points[:3]:\n            if isinstance(p, (tuple, list)) and len(p) >= 2:\n                flat_points.append((float(p[0]), float(p[1])))\n            else:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "calculate_dist_to_close",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def calculate_dist_to_close(points):\n    try:\n        if not points or len(points) < 2:\n            return 0\n        if all(isinstance(p, (tuple, list)) and len(p) >= 2 for p in points):\n            p1 = points[0]\n            p_last = points[-1]\n            return np.sqrt((p1[0] - p_last[0]) ** 2 + (p1[1] - p_last[1]) ** 2)\n        elif all(isinstance(t, (list, tuple)) and len(t) == 3 for t in points):\n            if not points[0] or not points[-1]:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "normalize_reward",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def normalize_reward(reward):\n    \"\"\"Normalize reward to a range of [-1, 1].\"\"\"\n    return 2 * (reward - REWARD_MIN) / (REWARD_MAX - REWARD_MIN) - 1\n# Advanced Reward System\ndef calculate_advanced_reward(shape, target, task, world):\n    try:\n        reward = 0\n        efficiency_factor = 1.0\n        creativity_factor = 1.0\n        constraint_penalty = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "calculate_advanced_reward",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def calculate_advanced_reward(shape, target, task, world):\n    try:\n        reward = 0\n        efficiency_factor = 1.0\n        creativity_factor = 1.0\n        constraint_penalty = 0\n        if task == TASK_LINE:\n            if not shape:\n                return normalize_reward(-10)\n            current_pos = shape[-1] if shape else (0, 0)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimize_model",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def optimize_model():\n    if memory.n_entries < batch_size:\n        return\n    batch, idxs, is_weights = memory.sample(batch_size, alpha=alpha)\n    is_weights = torch.FloatTensor(is_weights).to(device)\n    try:\n        state_batch, action_batch, reward_batch, next_state_batch, done_batch = zip(*batch)\n    except Exception as e:\n        log_message(f\"Error unpacking batch: {repr(e)}\")\n        return",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "store_transition",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def store_transition(transition):\n    n_step_buffer.append(transition)\n    if len(n_step_buffer) < n_step:\n        return\n    cumulative_reward = sum([(gamma**i) * t[2] for i, t in enumerate(n_step_buffer)])\n    state, action = n_step_buffer[0][0], n_step_buffer[0][1]\n    next_state, done = n_step_buffer[-1][3], n_step_buffer[-1][4]\n    memory.add(1.0, (state, action, cumulative_reward, next_state, done))\n    n_step_buffer.pop(0)\ndef plan_actions(state_tensor, model, current_shape, target, task, world, steps=3):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "plan_actions",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def plan_actions(state_tensor, model, current_shape, target, task, world, steps=3):\n    best_sequence = []\n    best_reward = -float(\"inf\")\n    state = state_tensor.squeeze(0).cpu().numpy()\n    for _ in range(10):\n        sequence = [np.random.randint(action_dim) for _ in range(steps)]\n        sim_state = state.copy()\n        sim_shape = current_shape.copy() if isinstance(current_shape, list) else []\n        total_reward = 0\n        for action in sequence:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "adjust_learning_rate",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def adjust_learning_rate(fps):\n    global optimizer\n    avg_reward = sum(episode_rewards) / len(episode_rewards) if episode_rewards else 0\n    current_lr = base_lr\n    if avg_reward > 10:\n        current_lr = min(base_lr * 2, 0.01)\n    elif avg_reward < -5:\n        current_lr = max(base_lr * 0.5, 0.0001)\n    if fps < 20:\n        current_lr *= 0.8",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "predict_next_shape",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def predict_next_shape():\n    global current_task, reward_history\n    avg_reward = sum(episode_rewards) / len(episode_rewards) if episode_rewards else 0\n    state = np.array(\n        [tasks.index(current_task), worlds.index(current_world), avg_reward]\n        + list(reward_history)\n        + [0] * (10 - len(reward_history))\n    )\n    state_tensor = torch.FloatTensor(state).unsqueeze(0).to(device)\n    with torch.no_grad():",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "reset_episode",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def reset_episode():\n    global start_point, triangle_points, circle_center, pentagon_points, tessellation_points, current_shape\n    global game_state, ai_step, current_task, end_point, circle_radius, negative_reward_attempts, positive_reward_attempts\n    global curriculum_progress\n    if negative_reward_attempts >= NEGATIVE_REWARD_RETRY_LIMIT:\n        log_message(\"Max retries for negative rewards reached. Moving to next task.\")\n        negative_reward_attempts = 0  # Reset retry counter\n        positive_reward_attempts = 0  # Reset positive retry counter\n    elif sum(rewards) < 0:\n        log_message(f\"Negative reward detected. Retrying task. Attempt {negative_reward_attempts + 1}/{NEGATIVE_REWARD_RETRY_LIMIT}.\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "generate_dynamic_task",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def generate_dynamic_task(allowed_tasks, allowed_worlds):\n    \"\"\"Generate a new dynamic task with random parameters within the allowed tasks and worlds.\"\"\"\n    task_type = random.choice(allowed_tasks)\n    world = random.choice(allowed_worlds)\n    if task_type == TASK_LINE:\n        start = (random.randint(50, WIDTH - 50), random.randint(50, HEIGHT - 50))\n        end = (random.randint(50, WIDTH - 50), random.randint(50, HEIGHT - 50))\n        return {\"type\": TASK_LINE, \"start\": start, \"end\": end, \"world\": world}\n    elif task_type == TASK_TRIANGLE:\n        points = [(random.randint(50, WIDTH - 50), random.randint(50, HEIGHT - 50)) for _ in range(3)]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "update_reward_plot",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def update_reward_plot():\n    global plot_surface, episode_rewards\n    plt.figure(figsize=(4, 2))\n    plt.plot(list(episode_rewards), label=\"Reward\", color=\"cyan\")\n    plt.xlabel(\"Episode\")\n    plt.ylabel(\"Avg Reward\")\n    plt.title(\"Reward Trend\")\n    plt.legend()\n    buf = BytesIO()\n    plt.savefig(buf, format=\"png\", bbox_inches=\"tight\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "update_dashboard",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def update_dashboard():\n    \"\"\"Update the real-time dashboard with rewards, losses, and task progression.\"\"\"\n    global dashboard_surface, episode_rewards, reward_history, step_counter\n    # Create a new figure for the dashboard\n    plt.figure(figsize=(8, 4))\n    # Subplot 1: Reward Trend\n    plt.subplot(1, 3, 1)\n    plt.plot(list(episode_rewards), label=\"Avg Reward\", color=\"cyan\")\n    plt.xlabel(\"Episode\")\n    plt.ylabel(\"Reward\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "save_model_weights",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def save_model_weights(task, world):\n    filename = f\"model_{task}_{world}.pth\"\n    torch.save(policy_net.state_dict(), filename)\n    log_message(f\"Model weights saved to {filename}\")\ndef load_model_weights(task, world):\n    filename = f\"model_{task}_{world}.pth\"\n    if os.path.exists(filename):\n        policy_net.load_state_dict(torch.load(filename))\n        target_net.load_state_dict(policy_net.state_dict())\n        log_message(f\"Model weights loaded from {filename}\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "load_model_weights",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def load_model_weights(task, world):\n    filename = f\"model_{task}_{world}.pth\"\n    if os.path.exists(filename):\n        policy_net.load_state_dict(torch.load(filename))\n        target_net.load_state_dict(policy_net.state_dict())\n        log_message(f\"Model weights loaded from {filename}\")\n    else:\n        log_message(f\"No saved weights found for {task} in {world}\")\n# Explainable AI (XAI)\ndef explain_decision(state_tensor):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "explain_decision",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def explain_decision(state_tensor):\n    with torch.no_grad():\n        q_values = policy_net(state_tensor).cpu().numpy().flatten()\n    # Numerically stable softmax\n    q_values_exp = np.exp(q_values - np.max(q_values))\n    action_probabilities = q_values_exp / np.sum(q_values_exp)\n    explanation = {\n        \"action_probabilities\": action_probabilities.tolist(),\n        \"q_values\": q_values.tolist(),\n    }",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "visualize_explanation",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def visualize_explanation(explanation):\n    plt.figure(figsize=(6, 4))\n    actions = [f\"Action {i}\" for i in range(len(explanation[\"action_probabilities\"]))]\n    plt.bar(actions, explanation[\"action_probabilities\"], color=\"cyan\")\n    plt.xlabel(\"Actions\")\n    plt.ylabel(\"Probability\")\n    plt.title(\"Action Probabilities\")\n    buf = BytesIO()\n    plt.savefig(buf, format=\"png\", bbox_inches=\"tight\")\n    buf.seek(0)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "evaluate_model",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def evaluate_model(num_episodes=10):\n    \"\"\"Evaluate the model's performance on predefined tasks.\"\"\"\n    global current_task, current_world, game_state, ai_step, current_shape, circle_radius\n    evaluation_rewards = []\n    success_count = 0\n    total_steps = 0\n    predefined_tasks = [\n        {\"task\": TASK_LINE, \"world\": WORLD_EUCLIDEAN},\n        {\"task\": TASK_TRIANGLE, \"world\": WORLD_SPHERICAL},\n        {\"task\": TASK_CIRCLE, \"world\": WORLD_HYPERBOLIC},",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tune_hyperparameters",
        "kind": 2,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "def tune_hyperparameters(avg_reward, fps):\n    \"\"\"Dynamically adjust hyperparameters based on performance.\"\"\"\n    global base_lr, epsilon_decay, REWARD_MIN, REWARD_MAX\n    # Adjust learning rate based on average reward\n    if avg_reward > 10:\n        base_lr = min(base_lr * 1.1, 0.01)  # Increase learning rate\n    elif avg_reward < -5:\n        base_lr = max(base_lr * 0.9, 0.0001)  # Decrease learning rate\n    # Adjust epsilon decay based on FPS\n    if fps < 20:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WIDTH",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WIDTH = 1000\nHEIGHT = 850\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"GeoMaster AI Challenge - Next Shape Predictor\")\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "HEIGHT",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "HEIGHT = 850\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"GeoMaster AI Challenge - Next Shape Predictor\")\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "screen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"GeoMaster AI Challenge - Next Shape Predictor\")\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "BLACK",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "BLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WHITE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()\ndebug_mode = False",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "RED",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "RED = (255, 0, 0)\nBLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()\ndebug_mode = False\ndef log_message(message):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "BLUE = (0, 0, 255)\nCYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()\ndebug_mode = False\ndef log_message(message):\n    if debug_mode:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "CYAN = (0, 255, 255)\nGREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()\ndebug_mode = False\ndef log_message(message):\n    if debug_mode:\n        log_queue.put(message)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "GREEN = (0, 255, 0)\n# Font\nfont = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()\ndebug_mode = False\ndef log_message(message):\n    if debug_mode:\n        log_queue.put(message)\ndef process_logs():",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "font = pygame.font.SysFont(\"monospace\", 20)\n# Thread-safe logging\nlog_queue = Queue()\ndebug_mode = False\ndef log_message(message):\n    if debug_mode:\n        log_queue.put(message)\ndef process_logs():\n    while not log_queue.empty():\n        print(log_queue.get())",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "log_queue",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "log_queue = Queue()\ndebug_mode = False\ndef log_message(message):\n    if debug_mode:\n        log_queue.put(message)\ndef process_logs():\n    while not log_queue.empty():\n        print(log_queue.get())\n# Helper function\ndef to_int_point(point):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "debug_mode",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "debug_mode = False\ndef log_message(message):\n    if debug_mode:\n        log_queue.put(message)\ndef process_logs():\n    while not log_queue.empty():\n        print(log_queue.get())\n# Helper function\ndef to_int_point(point):\n    if (",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_EUCLIDEAN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_EUCLIDEAN = \"Euclidean\"\nWORLD_SPHERICAL = \"Spherical\"\nWORLD_HYPERBOLIC = \"Hyperbolic\"\nWORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_SPHERICAL",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_SPHERICAL = \"Spherical\"\nWORLD_HYPERBOLIC = \"Hyperbolic\"\nWORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_HYPERBOLIC",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_HYPERBOLIC = \"Hyperbolic\"\nWORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_ELLIPTICAL",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_ELLIPTICAL = \"Elliptical\"\nWORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_PROJECTIVE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_PROJECTIVE = \"Projective\"\nWORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,\n]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "WORLD_FRACTAL",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "WORLD_FRACTAL = \"Fractal\"\nworlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,\n]\ncurrent_world = WORLD_EUCLIDEAN",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "worlds",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "worlds = [\n    WORLD_EUCLIDEAN,\n    WORLD_SPHERICAL,\n    WORLD_HYPERBOLIC,\n    WORLD_ELLIPTICAL,\n    WORLD_PROJECTIVE,\n    WORLD_FRACTAL,\n]\ncurrent_world = WORLD_EUCLIDEAN\nTASK_LINE = \"Draw Line\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_world",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_world = WORLD_EUCLIDEAN\nTASK_LINE = \"Draw Line\"\nTASK_TRIANGLE = \"Draw Triangle\"\nTASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_LINE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_LINE = \"Draw Line\"\nTASK_TRIANGLE = \"Draw Triangle\"\nTASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_TRIANGLE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_TRIANGLE = \"Draw Triangle\"\nTASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_CIRCLE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_CIRCLE = \"Draw Circle\"\nTASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_PENTAGON",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_PENTAGON = \"Draw Pentagon\"\nTASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "TASK_TESSELLATION",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "TASK_TESSELLATION = \"Draw Tessellation\"\ntasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "tasks = [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON, TASK_TESSELLATION]\ncurrent_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_task",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_task = TASK_LINE\n# Constants\nMAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "MAX_SCORE",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "MAX_SCORE = 50000\nNEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning\ncurriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "NEGATIVE_REWARD_RETRY_LIMIT",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "NEGATIVE_REWARD_RETRY_LIMIT = 3\nPOSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning\ncurriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks\n    [TASK_LINE, TASK_TRIANGLE],  # Stage 1: Line and triangle tasks",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "POSITIVE_REWARD_RETRY_LIMIT",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "POSITIVE_REWARD_RETRY_LIMIT = 3  # Number of additional attempts after achieving positive rewards\n# Curriculum learning parameters\ncurriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning\ncurriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks\n    [TASK_LINE, TASK_TRIANGLE],  # Stage 1: Line and triangle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE],  # Stage 2: Add circle tasks",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "curriculum_stage",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "curriculum_stage = 0\ncurriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning\ncurriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks\n    [TASK_LINE, TASK_TRIANGLE],  # Stage 1: Line and triangle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE],  # Stage 2: Add circle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON],  # Stage 3: Add pentagon tasks\n    tasks,  # Stage 4: All tasks",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "curriculum_threshold",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "curriculum_threshold = 10  # Number of successful episodes to progress to the next stage\ncurriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning\ncurriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks\n    [TASK_LINE, TASK_TRIANGLE],  # Stage 1: Line and triangle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE],  # Stage 2: Add circle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON],  # Stage 3: Add pentagon tasks\n    tasks,  # Stage 4: All tasks\n]",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "curriculum_progress",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "curriculum_progress = 0  # Tracks successful episodes in the current stage\n# Define task progression for curriculum learning\ncurriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks\n    [TASK_LINE, TASK_TRIANGLE],  # Stage 1: Line and triangle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE],  # Stage 2: Add circle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON],  # Stage 3: Add pentagon tasks\n    tasks,  # Stage 4: All tasks\n]\ncurriculum_worlds = [",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "curriculum_tasks",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "curriculum_tasks = [\n    [TASK_LINE],  # Stage 0: Only line tasks\n    [TASK_LINE, TASK_TRIANGLE],  # Stage 1: Line and triangle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE],  # Stage 2: Add circle tasks\n    [TASK_LINE, TASK_TRIANGLE, TASK_CIRCLE, TASK_PENTAGON],  # Stage 3: Add pentagon tasks\n    tasks,  # Stage 4: All tasks\n]\ncurriculum_worlds = [\n    [WORLD_EUCLIDEAN],  # Stage 0: Only Euclidean world\n    [WORLD_EUCLIDEAN, WORLD_SPHERICAL],  # Stage 1: Add spherical world",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "curriculum_worlds",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "curriculum_worlds = [\n    [WORLD_EUCLIDEAN],  # Stage 0: Only Euclidean world\n    [WORLD_EUCLIDEAN, WORLD_SPHERICAL],  # Stage 1: Add spherical world\n    [WORLD_EUCLIDEAN, WORLD_SPHERICAL, WORLD_HYPERBOLIC],  # Stage 2: Add hyperbolic world\n    [WORLD_EUCLIDEAN, WORLD_SPHERICAL, WORLD_HYPERBOLIC, WORLD_ELLIPTICAL],  # Stage 3: Add elliptical world\n    worlds,  # Stage 4: All worlds\n]\ndef update_curriculum():\n    \"\"\"Update the curriculum stage based on performance.\"\"\"\n    global curriculum_stage, curriculum_progress",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "state_dim_2d",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "state_dim_2d = 10\nstate_dim_3d = 11  # Add z or dz for 3D\nstate_dim = state_dim_2d  # Default to 2D\naction_dim = 6\npredictor_input_dim = 13\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "state_dim_3d",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "state_dim_3d = 11  # Add z or dz for 3D\nstate_dim = state_dim_2d  # Default to 2D\naction_dim = 6\npredictor_input_dim = 13\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "state_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "state_dim = state_dim_2d  # Default to 2D\naction_dim = 6\npredictor_input_dim = 13\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "action_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "action_dim = 6\npredictor_input_dim = 13\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "predictor_input_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "predictor_input_dim = 13\npredictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "predictor_output_dim",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "predictor_output_dim = len(tasks)\ngamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "gamma",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "gamma = 0.99\nepsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_start",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_start = 1.0\nepsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_end",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_end = 0.01\nepsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_decay",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_decay = 5000\nepsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon = epsilon_start\nbatch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "batch_size",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "batch_size = 64\nmemory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "memory_size",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "memory_size = 10000\ntarget_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "target_update",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "target_update = 10\nn_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "n_step",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "n_step = 3\nalpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "alpha = 0.7\nbeta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "beta",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "beta = 0.5\nbase_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "base_lr",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "base_lr = 0.001\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npolicy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "policy_net",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "policy_net = DQN(state_dim, action_dim).to(device)\ntarget_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "target_net",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "target_net = DQN(state_dim, action_dim).to(device)\ntarget_net.load_state_dict(policy_net.state_dict())\noptimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer = optim.Adam(policy_net.parameters(), lr=base_lr)\nforward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "forward_model",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "forward_model = ForwardModel(state_dim, action_dim).to(device)\noptimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer_fm",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer_fm = optim.Adam(forward_model.parameters(), lr=base_lr)\nworld_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "world_model",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "world_model = WorldModel(state_dim, action_dim).to(device)\noptimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer_wm",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer_wm = optim.Adam(world_model.parameters(), lr=base_lr)\nshape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "shape_predictor",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "shape_predictor = NextShapePredictor(predictor_input_dim, predictor_output_dim).to(device)\noptimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:\n        # Exploration: Add noise to a random action",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "optimizer_sp",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "optimizer_sp = optim.Adam(shape_predictor.parameters(), lr=0.001)\nmemory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:\n        # Exploration: Add noise to a random action\n        action = random.randint(0, action_dim - 1)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "memory",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "memory = SumTree(memory_size)\nn_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:\n        # Exploration: Add noise to a random action\n        action = random.randint(0, action_dim - 1)\n        noise = np.random.normal(0, epsilon_noise_scale, size=action_dim)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "n_step_buffer",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "n_step_buffer = []\n# Adaptive exploration parameters\nepsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:\n        # Exploration: Add noise to a random action\n        action = random.randint(0, action_dim - 1)\n        noise = np.random.normal(0, epsilon_noise_scale, size=action_dim)\n        noisy_action = np.clip(action + noise[action], 0, action_dim - 1)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "epsilon_noise_scale",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "epsilon_noise_scale = 0.1  # Scale of noise added to actions during exploration\ndef select_action(state_tensor, epsilon, action_dim):\n    \"\"\"Select an action using epsilon-greedy with noise.\"\"\"\n    if random.random() < epsilon:\n        # Exploration: Add noise to a random action\n        action = random.randint(0, action_dim - 1)\n        noise = np.random.normal(0, epsilon_noise_scale, size=action_dim)\n        noisy_action = np.clip(action + noise[action], 0, action_dim - 1)\n        return int(noisy_action)\n    else:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "start_point",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "start_point = None\nend_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "end_point",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "end_point = (WIDTH - 50, HEIGHT - 50)\ntriangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "triangle_points",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "triangle_points = []\ncircle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "circle_center",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "circle_center = None\ncircle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "circle_radius",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "circle_radius = 50\npentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "pentagon_points",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "pentagon_points = []\ntessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tessellation_points",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "tessellation_points = []\ncurrent_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_shape",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_shape = []\nai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "ai_step",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "ai_step = 0\nmax_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "max_steps",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "max_steps = 50\ngame_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "game_state",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "game_state = \"waiting\"\nrunning_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "running_state",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "running_state = \"stopped\"\nrewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "rewards",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "rewards = deque(maxlen=100)\nepisode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "episode_rewards",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "episode_rewards = deque(maxlen=100)\nreward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "reward_history",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "reward_history = deque(maxlen=10)\ncurrent_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "current_reward",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "current_reward = 0\nglobal_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "global_step",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "global_step = 0\nepisode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "episode_count",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "episode_count = 0\ntick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "tick_rate",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "tick_rate = 30\ntrain_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "train_iters",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "train_iters = 1\nnegative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "negative_reward_attempts",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "negative_reward_attempts = 0  # Track retries for negative rewards\npositive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "positive_reward_attempts",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "positive_reward_attempts = 0  # Track retries for positive rewards\n# Logging\nlog_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [\n                \"Episode\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "log_file",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "log_file = \"ai_calculations.csv\"\nfile_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [\n                \"Episode\",\n                \"Step\",\n                \"State\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "file_exists",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "file_exists = os.path.isfile(log_file)\nwith open(log_file, mode=\"a\", newline=\"\") as f:\n    writer = csv.writer(f)\n    if not file_exists:\n        writer.writerow(\n            [\n                \"Episode\",\n                \"Step\",\n                \"State\",\n                \"Action\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "is_3d_mode",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "is_3d_mode = False\nprojection_mode = \"perspective\"  # Options: \"perspective\", \"orthographic\"\ndef update_network_dimensions():\n    global policy_net, target_net, forward_model, world_model, state_dim\n    state_dim = state_dim_3d if is_3d_mode else state_dim_2d\n    log_message(f\"Updating network dimensions: state_dim={state_dim}, is_3d_mode={is_3d_mode}\")\n    policy_net = DQN(state_dim, action_dim).to(device)\n    target_net = DQN(state_dim, action_dim).to(device)\n    target_net.load_state_dict(policy_net.state_dict())\n    forward_model = ForwardModel(state_dim, action_dim).to(device)  # Re-initialize with updated state_dim",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "projection_mode",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "projection_mode = \"perspective\"  # Options: \"perspective\", \"orthographic\"\ndef update_network_dimensions():\n    global policy_net, target_net, forward_model, world_model, state_dim\n    state_dim = state_dim_3d if is_3d_mode else state_dim_2d\n    log_message(f\"Updating network dimensions: state_dim={state_dim}, is_3d_mode={is_3d_mode}\")\n    policy_net = DQN(state_dim, action_dim).to(device)\n    target_net = DQN(state_dim, action_dim).to(device)\n    target_net.load_state_dict(policy_net.state_dict())\n    forward_model = ForwardModel(state_dim, action_dim).to(device)  # Re-initialize with updated state_dim\n    world_model = WorldModel(state_dim, action_dim).to(device)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "animation_time",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "animation_time = 0\ndef draw_wireframe(world):\n    global animation_time\n    animation_time += 0.05\n    pulse = 0.5 + 0.5 * np.sin(animation_time)\n    def gradient_color(t):\n        r = int(0 * (1 - t) + 0 * t)\n        g = int(0 * (1 - t) + 255 * t)\n        b = int(255 * (1 - t) + 255 * t)\n        return (r, g, b)",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "REWARD_MIN",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "REWARD_MIN = -50  # Minimum possible reward\nREWARD_MAX = 50   # Maximum possible reward\ndef normalize_reward(reward):\n    \"\"\"Normalize reward to a range of [-1, 1].\"\"\"\n    return 2 * (reward - REWARD_MIN) / (REWARD_MAX - REWARD_MIN) - 1\n# Advanced Reward System\ndef calculate_advanced_reward(shape, target, task, world):\n    try:\n        reward = 0\n        efficiency_factor = 1.0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "REWARD_MAX",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "REWARD_MAX = 50   # Maximum possible reward\ndef normalize_reward(reward):\n    \"\"\"Normalize reward to a range of [-1, 1].\"\"\"\n    return 2 * (reward - REWARD_MIN) / (REWARD_MAX - REWARD_MIN) - 1\n# Advanced Reward System\ndef calculate_advanced_reward(shape, target, task, world):\n    try:\n        reward = 0\n        efficiency_factor = 1.0\n        creativity_factor = 1.0",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "plot_surface",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "plot_surface = None\ndef update_reward_plot():\n    global plot_surface, episode_rewards\n    plt.figure(figsize=(4, 2))\n    plt.plot(list(episode_rewards), label=\"Reward\", color=\"cyan\")\n    plt.xlabel(\"Episode\")\n    plt.ylabel(\"Avg Reward\")\n    plt.title(\"Reward Trend\")\n    plt.legend()\n    buf = BytesIO()",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "dashboard_surface",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "dashboard_surface = None\ndef update_dashboard():\n    \"\"\"Update the real-time dashboard with rewards, losses, and task progression.\"\"\"\n    global dashboard_surface, episode_rewards, reward_history, step_counter\n    # Create a new figure for the dashboard\n    plt.figure(figsize=(8, 4))\n    # Subplot 1: Reward Trend\n    plt.subplot(1, 3, 1)\n    plt.plot(list(episode_rewards), label=\"Avg Reward\", color=\"cyan\")\n    plt.xlabel(\"Episode\")",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "clock",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "clock = pygame.time.Clock()\nrunning = True\nlast_plot_update = 0\nstep_counter = 0\n# Command handling via Pygame keys\ncommand_keys = {\n    pygame.K_s: \"start\",\n    pygame.K_p: \"pause\",\n    pygame.K_r: \"resume\",\n    pygame.K_q: \"quit\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "running",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "running = True\nlast_plot_update = 0\nstep_counter = 0\n# Command handling via Pygame keys\ncommand_keys = {\n    pygame.K_s: \"start\",\n    pygame.K_p: \"pause\",\n    pygame.K_r: \"resume\",\n    pygame.K_q: \"quit\",\n    pygame.K_f: \"faster\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "last_plot_update",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "last_plot_update = 0\nstep_counter = 0\n# Command handling via Pygame keys\ncommand_keys = {\n    pygame.K_s: \"start\",\n    pygame.K_p: \"pause\",\n    pygame.K_r: \"resume\",\n    pygame.K_q: \"quit\",\n    pygame.K_f: \"faster\",\n    pygame.K_l: \"slower\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "step_counter",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "step_counter = 0\n# Command handling via Pygame keys\ncommand_keys = {\n    pygame.K_s: \"start\",\n    pygame.K_p: \"pause\",\n    pygame.K_r: \"resume\",\n    pygame.K_q: \"quit\",\n    pygame.K_f: \"faster\",\n    pygame.K_l: \"slower\",\n    pygame.K_u: \"iters_up\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    },
    {
        "label": "command_keys",
        "kind": 5,
        "importPath": "geomaster_ai_challenge",
        "description": "geomaster_ai_challenge",
        "peekOfCode": "command_keys = {\n    pygame.K_s: \"start\",\n    pygame.K_p: \"pause\",\n    pygame.K_r: \"resume\",\n    pygame.K_q: \"quit\",\n    pygame.K_f: \"faster\",\n    pygame.K_l: \"slower\",\n    pygame.K_u: \"iters_up\",\n    pygame.K_d: \"iters_down\",\n    pygame.K_b: \"toggle_debug\",",
        "detail": "geomaster_ai_challenge",
        "documentation": {}
    }
]